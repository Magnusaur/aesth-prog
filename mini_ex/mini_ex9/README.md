# Showcharts
This week is a little different. No coding exercise. Instead, a couple of flowcharts and some reflections on the final project. First up is my individually created flowchart, based on my pride and joy: Frog Blaster! To visit the program in question, [click here.](https://github.com/Magnusaur/aesth-prog/tree/master/mini_ex/mini_ex5) 
## Solocharts
![alt](https://github.com/Magnusaur/aesth-prog/blob/master/mini_ex/mini_ex9/frogs_chart.jpg)

Frog Blaster is a game of sorts, where you manually create moving targets (frogs) and then blast them by aiming with and clicking the mouse. Whenever a frog is blasted, the score is updated and a sound clip plays triumphantly. The never ends, except when you get sick of the otherwise catchy beat. Creating a flowchart is easy and difficult at the same time. There are some great tools out there for creating flowcharts. I used draw.io, which I also made use of during the previous semester. So actually creating the rectangles, arrows and circles is pretty straight-forward, but what goes in the flowchart? La Cour, a fellow group member made an impressive flowchart, identifying and relating almost every single procedure in his program to each other. I chose to keep things a little more abstract, which certainly makes things more manageable. 

And that kind of is the point, isn't it? To get an overview, however simplified, of the program in question. It is interesting how the simplification and the usefulness of flowcharts appear to be intrinsically linked. Of course it depends on who the chart is created for, but in some cases it may ultimately turn out to be just as complex as the underlying code being presented. Still, flowcharts can structure things in a sort of hierarchy and as such I find them to be not just useful, but also rather emblematic of the virtues of the Digital Design programme as a whole: the ability to see things in patterns, hierarchies, (causal) relations, etc. In the creation of flowcharts, however, there is a degree of ambiguity as to how they should be made. In my particular case, I chose to lump certain aspects together (music plays, frog moves) because discerning between them did not see terribly important. Actually, I just realized that you could argue for a more specific flowchart of the frog's behavior. That is, what happens when it is created, when it hits a wall, and so on? Oops. Another question (I hesitate to use the word 'challenge') was how to best represent an almost perpetual source of input from the user (player), like moving the mouse around. In a sense, a flowchart is perhaps as interesting because of what isn't in it.

## Groupcharts
So, we sat together in a group and talked about ideas for the final project. We cooked up two different projects and accordingly created two flowcharts. The first one is this.

### Some kind of game
![alt](https://github.com/Magnusaur/aesth-prog/blob/master/mini_ex/mini_ex9/game_chart.jpg)

We envisioned some kind of game, possibly a derivative of Pac-Man, in which light plays a central role. Not just in the game, but also outside of. We discussed using a light-dependent resistor as part of the control scheme. Personally, I think this flowchart is legible, but too complex, owing to 1) our desire and enthusiasm to actually work on the game, suggesting all sorts of ideas and 2) having not settled on certain aspects of the game, being required to keep certain elements rather vague, like the exact role and purpose of the resistor. It is perhaps not clear what the exact objective of the game is, nor what it is like to play it. But I do think that the flowchart effectively conveys that not only are there a lot of moving parts at play; they also interact and intersect in interesting ways. 

The second flowchart is this.
### Some kind of webpage

![alt](https://github.com/Magnusaur/aesth-prog/blob/master/mini_ex/mini_ex9/webpage_chart.jpg)

... In which an API providing data about convicts, including mugshots (yes, it's actually a thing) would be used in conjunction with a faux facebook page. Possibly to highlight the grotesque nature of certain API's or how facebook is actually a prison, or whatever. In any case, this flowchart is a lot more straight-forward, perhaps because it is more static in nature, or because what exactly happens when clicking certain things is not very clear. The flowchart also gives off the impression of being more linear in use, which may or may not actually be the case. 

## Differences & Difficulties
How are these two conceptual flowcharts different from the one in the beginning? Well, first of, they refer to something non-existent. We have not actually created these hypothetical programs, and as such it really is not possible to validate their "soundness" or congruity. Or is it? Perhaps one really can point out certain logical contradictions in a flow chart, similarly to how "logic trees" work. Regardless, it is somewhat of a challenge, going through the procedural motions of a program that actually is not there. 

